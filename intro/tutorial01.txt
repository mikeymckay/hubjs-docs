.. _intro-tutorial01:

============================================
Writing your first hub.js data model, part 1
============================================

Let's learn by example.

Throughout this tutorial, we'll walk you through the creation of a data model 
for a todo list application with shared todo lists and multiple, simultaneous 
users that syncs updates to multiple devices, on multiple platforms, in 
real-time. We'll also demonstrate how easy it is to integrate our new hub.js 
data model into an existing app or server.

Finally, we'll be demonstrating the portability of our new hub.js data model by 
running the code on multiple platforms. For simplicity, you should follow along 
with your primary platform and skim the documentation for the others to get a 
sense of the effort involved.

Along the way, we'll be describing the internals of hub.js and how the 
innovative Hub data structure at the heart of hub.js makes efficient, 
reliable, universal sync and storage for arbitrary data models possible.

This tutorial consists of five parts:

    * A hub.js data model definition plus custom User and Device subclasses. 
      This part is platform-independent and portable. (The remaining steps are 
      required to use hub.js and the data model on a specific platform.)
    * An implementation of the :ref:`device storage API <topics-device>` on 
      mulitple platforms.
    * An implementation of the :ref:`sync API <topics-sync>` on multiple 
      platforms with `nodered`_ serving as our sync server.
    * An implementation of the :ref:`remote storage API <topics-sync>` on 
      multiple platforms with the `hub.js reference AppEngine app`_.
    * An implementation of the :ref:`integration API <topics-sync>` on multiple 
      platforms. Though we won't actually have a legacy API to integrate with, 
      the foundation will be there. If you have an existing todo list app, you 
      are encouraged to try using the integration API with that app.

.. _nodered: http://github.com/fictorial/nodered
.. _hub.js reference AppEngine app: http://github.com/hubjs/hubjs-appengine

We'll assume you have a :ref:`copy of hub.js <intro-install>` already. You 
should use the development copy of hub.js for this tutorial.

.. admonition:: Where to get help:

    If you're having trouble going through this tutorial, please post a message
    to the `hubjs group`__ or drop by `#hub.js on irc.freenode.net`__ to chat
    with other hub.js users who might be able to help.

__ http://groups.google.com/group/hubjs/
__ irc://irc.freenode.net/hub.js

Model-View-Controller
=====================

hub.js is designed around the model-view-controller (MVC) paradigm (with hub.js 
implementing the model layer). **In order to understand how to write a data model 
with hub.js, you need to understand how the data model will be used by the 
controller and view layers.**

hub.js implements a particular variant of MVC, with the layers arranged as a 
vertical stack::

    View Layer
    Controller Layer
    Model Layer
        your data model
        hub.js

Modern model layers like hub.js are designed specifically for event-driven 
apps.

.. admonition:: Adopt MVC-driven development

  MVC layers are a logical construct, not a technical one. You are free to 
  violate the layering in your app at any time. If you do, however, the result 
  is usually an update anomally: the view layer will not be consistent with the 
  controller layer which will not be consistent with the model layer. These 
  kinds of bugs are very difficult to find and fix manually. The best solution 
  is to apply MVC layering consistently, preventing the bugs in the first place.
  
  hub.js is specifically designed to support strict MVC layering. By adopting 
  the approach presented here, and thinking of your app in layers and the 
  events as propogating in a predictable route through those layers (aka the 
  "V" property), your app will be robust to model layer updates and new event 
  types.

Doing nothing is normal
-----------------------

In an event-driven app, the app is usually in a dormant state with no code 
running. The app is "woken up" by the platform when an event occurs, usually by 
invoking a callback inside the app. For example, on the browser, you register 
callbacks for specific events using the DOM API. (On Mac OS X, Cocoa typically 
registers for events with the operating system for you; you do not need to 
register for events manually.)

When an event callback is called by the platform, the event is handled in a 
"run-to-completion" manner. Simply put, this means that no other events will be 
handled while the callback is running. If another event occurs while the 
current event is being handled, the platform will *queue* the event and invoke 
the appropriate callback in your app at a later time.

Each callback from the platform conceptually occurs at a specific level of the 
MVC architecture. For a "mouse down" event, the callback is occurring in the 
view layer. When an app supports a scripting language such as AppleScript, each 
scripting call is considered to be a callback event and the event "occurs" in 
the controller layer. Finally, storage- and network-related callback events are 
usually considered to have occurred in the model layer.

Propagating changes
-------------------

Event callbacks are important because they are the only way to produce a change 
in the state of your app. Strict MVC layering is important because it specifies 
*how* a change that is made is propagated throughout your app, based on the 
MVC layer the change originated from and the MVC layers that change affects.

In previous MVC architectures, change propagation was left undefined. Each app 
developer would write custom "glue" code to propagate changes in their app. In 
many cases, the bulk of an app was made up of glue code! Because this code was 
ill-defined and typically written in an *ad hoc* fashion, the predictable 
result was apps with frequent "update bugs" where the UI became inconsistent 
with the controller and model layers (and vice versa).

hub.js provides a solid foundation for addressing change propagation in your 
app by implementing comprehensive key-value coding and key-value observing 
support.

Key-value coding
----------------

Key-value coding (KVC) is a critical enabling technology in the modern MVC 
stack, and hub.js includes a robust, efficient KVC implementation written 
entirely in JavaScript. By adopting hub.js for your model layer, your apps will 
have access to KVC on every platform.

KVC simply means that you work with your objects as if they were dictionaries. 
A "key" is used to access properties, and the "value" is returned. In hub.js, 
key-value coding is done using the ``.get()`` and ``.set()`` methods that are 
part of most objects in hub.js.

Here's an example of using KVC to get the value of a property::

    >>> var obj = hub.Object.create({ firstName: "Erich", lastName: "Ocean" });
    >>> obj.get('firstName');
    "Erich"
    >>> obj.get('lastName');
    "Ocean"

You can even implement computed properties, by associating a property name with
a function and calling ``.property()``::

    >>> var obj = hub.Object.create({
    ...     firstName: "Erich", lastName: "Ocean",
    ...     fullName: function(key, val) {
    ...         return this.getEach('firstName', 'lastName').join(" ");
    ...     }.property('firstName', 'lastName').cacheable()
    ... });
    >>> obj.get('fullName');
    "Erich Ocean"

If you don't call ``.property()``, the function object itself will be returned::

    >>> var obj = hub.Object.create({
    ...     firstName: "Erich", lastName: "Ocean",
    ...     fullName: function(key, val) {
    ...         return this.getEach('firstName', 'lastName').join(" ");
    ...     }
    ... });
    >>> obj.get('fullName');
    Function

Here's an example of using KVC to set the value of a property::

    >>> var obj = hub.Object.create({ isClosed: false });
    >>> obj.get('isClosed');
    false
    >>> obj.set('isClosed', true);
    >>> obj.get('isClosed');
    true

As you can see, key-valued coding is a simple, easy-to-use API for property 
access. You will always use KVC to access the public properties of your objects 
when you work with hub.js.

Key-value observing
-------------------

When you update an object using key-value coding, you can take advantage of 
hub.js' support for key-value observing (KVO).

KVO means that changes made via KVC can be observed, without having to modify 
the object or property you're tryng to observe. To observe an arbitrary 
property on an object for changes, you'll use ``.observes()``::

    >>> var obj = hub.Object.create({
    ...     isClosed: false,
    ...     isClosedDidChange: function(target, key, revision) {
    ...         console.log("isClosed did change to " + this.get('isClosed'));
    ...     }.observes('isClosed')
    ... });
    >>> obj.set('isClosed', true);
    isClosed did change to true

It is not necessary to name the function doing the observing anything in 
particular. Instead of ``isClosedDidChange()``, we could have named it 
``foo()`` or ``bar()``.

You can pass in multiple keys into ``.observes()`` and use the ``key`` argument 
to determine which key changed::

    >>> var obj = hub.Object.create({
    ...     isClosed: false,
    ...     hasDonuts: true,
    ...     uberDidChange: function(target, key, revision) {
    ...         console.log(key + " did change to " + this.get(key));
    ...     }.observes('isClosed', 'hasDonuts')
    ... });
    >>> obj.set('isClosed', true);
    isClosed did change to true
    >>> obj.set('hasDonuts', false);
    hasDonuts did change to false

.. admonition:: hub.Observable

    Only objects that include the ``hub.Observable`` mixin and call 
    ``this.initObservable()`` participate in key-value coding and key-value 
    observing. ``hub.Object`` does this for you automatically, but if you 
    create objects that are not set up propertly, be aware that KVC and KVO 
    will not function as intended with those objects.
    
    If this is jibberish to you, just be aware that you need to use 
    ``hub.Object`` or the other classes in hub.js if you want to use KVC and 
    KVO. All of the code in this tutorial supports KVC and KVO.

Changes you make with KVC are propogated to observers *before* ``.set()`` 
returns. This means that after a call to ``.set()``, you can be sure that all 
observers have been notified of the change.

There's a lot more to hub.js' KVC and KVO support, but this is as far as we're 
going to go in this tutorial. You are encouraged to 
:ref:`read the documentation <topics-mixins-observable>` in detail.

.. admonition:: No run loop or bindings

    hub.js does not include a run loop abstraction or bindings, although both 
    are easy to add to hub.js. In fact, hub.js includes no event handling 
    support whatsoever. Instead, there are callback APIs for sync, storage, and 
    integration with legacy model layers.

The "V" property
================

Understanding and respecting the "V" property is perhaps the most important 
aspect of working with hub.js and using data models built with hub.js in actual 
apps.

The "V" property is a way to visualize the handling of a single event callback 
and the state changes it causes as they propagate through the MVC stack. More 
specifically, the "V" property specifies *what kinds of changes* to the state of 
your app are legal to make at various point on the "V".

By respecting these *change points*, apps you build on top of a hub.js data 
model will always propogate changes correctly, regardless of how those changes 
enter the app.

Remember: in a hub.js model layer, many updates are the result of sync, which 
conceptually enter the MVC stack at the bottom (this is also the bottom of the 
"V"). The model layer does not contain any app-specific code, so it is 
necessary to specify a protocol for notifying the app of updates to the model 
layer that occur outside of the app's view. This is what the "V" property 
specifies and why it is *crucial* that both the data model and apps that use it 
respect the change notification protocol.

Change points
-------------

An app that has the "V" property is an app that respects the change points on 
the "V" -- it only makes specific kinds of updates to the app's data structures 
when the update is allowed by the "V".

There are five change points on the "V". They are:

    * Event callbacks that enter the view layer, for example, mouse events.
    * Event callbacks that enter the controller layer, for example, scripting 
      language callbacks (AppleScript).
    * Event callbacks that enter the model layer, for example, the various 
      callback APIs in hub.js.
    * Observer notifications in the controller layer, in response to changes in 
      the model layer.
    * Observer notifications in the view layer, in response to changes in the 
      controller layer.

In the most general case, a mouse event enters the view layer, triggers an 
"action" in the controller layer, which calls an API in the model layer to 
perform the action. These are the first three change points described above.

When the action is performed, the controller layer is notifed by a property 
observer and a property update in the controller layer is made as a result. 
This is the fourth change point.

Finally, a view observing the object in the controller layer that was just 
updated is notified and as a result redraws itself to reflect the change. This 
is the fifth change point.

In the example just given, all five change points along the "V" were passed. In 
general, it is not a requirement that every event pass through all five change 
points. For example, a mouse down event that enter a mouse tracking loop would 
only involve two change points, the first and the last, without involving the 
control layer or the model layer at all.

Preventing update anomalies
---------------------------

As far as importance goes, the last two change points are the most critical:
**All updates to the state of the controller layer that are dependent on the 
model layer should be in response to property observer callbacks in the model 
layer.** A similar rule is in effect for the view layer, which should only 
redrawn visual attributes derived from objects in the controller and model 
layers when it is notified via property observer callbacks that they have 
changed.

What these change points disallow are updates in the controller and view layers 
that are made based on *what they expect the model layer to look like*. For 
example, consider a checkbox in the view layer that is displaying the content 
of an object proxy in the controller layer this is proxing a record from the 
model layer. In a nutshell, the checkbox is supposed to reflect the state of 
the 'isClosed' property on a record from the model layer.

Now, suppose the "V" property is not respected and the view updates the 
checkbox only when it is clicked, that is, at the first change point (instead 
of the last, which is what the "V" property would require).

Here's the view logic: if the checkbox is "checked" when the mouse 
clicks it, the view immediately redraws itself as "unchecked" and then forwards 
the change on to the controller layer, which further forwards the change to the 
model layer where it is recorded persistently by hub.js.

If the app only ever handled mouse clicks, and assuming the controller layer or 
model layer **never** rejected the update (a highly dubious assumption), this 
code would appear to work correctly. Nevertheless, the code does **not** have 
the "V" property because the change to its visual state is done at the wrong 
change point (the first change point instead of the last).

To demonstrate why the "V" property is important, let's update the data model 
to reject all changes to the 'isClosed' property. It's now "read only". Now 
when the user clicks the checkbox, it still changes, but the change is *wrong*, 
because the update will be rejected! We now have an update anomaly, aka, a bug. 
What's worse, *nothing in our app changed!* We just updated the data model to a 
newer version and our app broke. Not good.

At this juncture, we *could* modify the app to disable the checkbox, or check 
with the controller or the model before updating, or any number of other hacks 
-- all of which, it turns out, are irrelevant because the real bug is that the 
view layer's job is to display data in the controller and model layer, whatever 
that data is.

If the view adopts the "V" property, not only will the previous bug be fixed, 
but any futher changes to the controller and model layers will also be handled 
correctly as well. Simply put, adopting the "V" property fixes the problem, not 
the symptom.

You should always respect the "V" property in your data model and in apps you 
write with hub.js.

KVO is the key to adopting the "V" property
-------------------------------------------

From the above description, it should be clear that key-value observing is what 
makes the "V" property and change points possible. KVO, then, serves as the 
foundational rule of data model design: always, *always*, **always** update the 
objects in your data model in an observable way.

If you use KVC to make changes, this will happen automatically and everything 
wil Just Work. But occassionaly, for performance or otherwise, you may want to 
make changes for a brief period of time with KVO disabled. This is perfectly 
okay, so long as any KVO notifications are made *before* the next change point 
is reached. That way, an app that is written to respect the "V" property will 
be able to update its state correctly in response to the changes.

Data models
===========

With those preliminaries out of the way, we're now ready to tackle the data 
model itself. In general, a data model consists of three parts:

    * The schema. These are the subclasses of hub.Record, plus descriptions of 
      the attributes of each record and the relationships between them, plus 
      any relevant computed properties (for example, ``fullName``).
    * The views. These are instantiations of hub.RecordArray and friends for 
      particular queries. In principle, it is also possible for apps to 
      generate their own queries and record arrays, but this is not recommended 
      for performance reasons (to be explained later).
    * The API. This is the API (beyond KVC) that apps will use to update the 
      model layer. You'll provide APIs to support larger operations that span 
      multiple records or classes of records in a single call. You'll also 
      provide APIs to create new hubs, users, devices, etc. that work properly 
      with the larger server environment the data model is a part of.

Together, these three parts constitute the *public API* for your data model. If 
you were to write documentation for your API, this is what you would document.

The namespace
-------------

Each application should have a single, global object that acts as the namespace 
of their application. To take advantage of KVC and KVO, it's helpful to make 
this object an instance of ``hub.Object``::

    // establish a namespace for our data model
    var TaskList = hub.Object.create({
        VERSION: '0.1'
    });

As you can see, the ``.create()`` class method takes a single JavaScript hash 
as the properties of the new object. In hub.js, you generally do not need to 
write an ``init()`` method like most other libraries.

This style of coding, where the object is constructed directly, in-place, 
instead of indirectly using template methods like ``init()`` is used throughout 
the hub.js API. We find that programs written in this style are shorter, easier 
to write, and easier to understand.

.. admonition:: Using closures

    If you wrap your data model in a closure, you'll need to do a little bit of 
    extra work so that hub.js can find your record classes at runtime. This is 
    also true if you package your data model with `CommonJS`__.

__ http://commonjs.org

The schema
----------

``hub.Record`` is the primary superclass for persistent objects. You'll 
subclass ``hub.Record`` for each record class in your data model.

To create a subclass, you'll use the ``.extend()`` class method, which has an 
API very similar to ``.create()``::

    TaskList.Task = hub.Record.extend({
        isDone: hub.attr(Boolean, { default: false }),
        description: hub.attr(String, { default: "" })
    });

For now, we'll ignore any relationships and just define the attributes of the 
``Task`` record type.

The ``hub.attr()`` function is a helper method that constructs an instance of 
the ``hub.RecordAttribue`` class. ``hub.RecordAttribute`` is recognized as a 
computed property by the hub.js KVC implementation.

Record attributes are used to transform the underlying ``attributes`` hash of 
the record into the type of object expected by the rest of the data model. For 
instance, you could have a string in the ``attributes`` hash with the value 
``"12 56 123"`` representing the RGB values of a color. If you were to register 
an attribute transformer with hub.js, you could transform that string into a 
JavaScript ``Color`` object when ``.get()`` is called. Similarly, you would 
serialize the ``Color`` object back into a string when the record needed to be 
saved.

Assuming a record attribute transformed for the ``Color`` exists, here's how 
you would use it::

    TaskList.Task = hub.Record.extend({
        isDone: hub.attr(Boolean, { default: false }),
        description: hub.attr(String, { default: "" }),
        color: hub.attr(Color, { default: new Color(127, 127, 127) })
    });

As you can see, custom attribute transformers are first class citizens in 
hub.js.

Created by
----------

In our schema, we'd like to know who created a specific ``Task``. In hub.js, 
users are represented as instances of the ``hub.User`` class (or a subclass), 
and there is an API call to get the ``hub.User`` that created a particular 
record, so we'll create a computed property that calls that::

    TaskList.Task = hub.Record.extend({
        isDone: hub.attr(Boolean, { default: false }),
        description: hub.attr(String, { default: "" }),
        
        createdBy: function(key, val) {
            if (val) hub.debug("You can't change the creator of an object.");
            return hub.author(this);
        }.property().cacheable()
    });

Since this is a pretty standard thing to do, hub.js provides a pre-made 
attribute you can use that does the same thing::

    TaskList.Task = hub.Record.extend({
        isDone: hub.attr(Boolean, { default: false }),
        description: hub.attr(String, { default: "" }),
        
        createdBy: hub.AuthorAttribute
    });

And here's the definition of ``hub.AuthorAttribute``::

    hub.AuthorAttribute = function(key, val) {
        if (val) hub.debug("You can't change the author of a record.") ;
        return hub.author(this) ;
    }.property().cacheable();

.. admonition:: Don't add the ()'s

    You want to re-use the ``hub.AuthorAttribute`` function, not call it, so 
    don't add the parenthesis!

Similar function exists for ``hub.Device`` and other attributes that are part 
of the Hub data structure itself.

Relationships
-------------

We'd like to have more than one task list in our app, so our first instinct 
would be to create a ``TaskList.TalkList`` class with a 
``.toMany('TalkList.Task')`` relationship. As it turns out, this design isn't 
very flexible.

To see why, we need to think a little bit about *sharing*. One goal of our data 
model is to be able to create and update shared task lists. Although in 
principle we could place unshared and shared task lists in the same hub, this 
would complicate our sharing efforts considerably.

First, placing shared and unshared tasks in the same hub means that we'll be 
sharing *all* of our tasks, not just the shared ones, since they'll all be in 
the same hub. This is probably not what we want.

A better architecture is to use *one hub per task list*.

If you come from the RDBMS world, this will seem odd, but to a typical desktop 
application developer, this approach makes total sense. In general, it's better 
to think of a hub as if it were a file, not a database. Just like it doesn't 
make sense to share *part of* a file, it doesn't make sense to share *part of* 
a hub. It's an all or nothing thing.

By storing all of the tasks is a single task list in one hub (and nothing 
else), we can share and update each task list independently. Whenever we want a 
new task list, we'll create a new hub just for that task list. Whenever we want 
to share a task list, we'll share the hub for that task list.

You will frequently have multiple hubs open in the same app, in the same way a 
desktop application frequently has multiple documents open. How you display 
these hubs to people is up to the app.

Let's provide an API for creating a new task list. First we need to define 
the hub itself::

    TaskList.Hub = hub.Hub.extend({
        uti: 'com.example.tasklist'
    });

.. admonition:: Unifrom type identifiers

    The ``UTI``, or `Uniform Type Identifier`_, is a system developed by Apple for 
    indicating the type of data something is. It's a continuation of the ubiquitous 
    MIME type on the Internet, but more flexible. hub.js has pervasive support for 
    UTIs.

.. _Uniform Type Identifier: http://en.wikipedia.org/wiki/Uniform_Type_Identifier

Now that we've got our ``hub.Hub`` subclass defined, we can provide API to 
create new hubs::

    TalkList.new = function() {
        return TaskList.Hub.create();
    };

And in our app, we'll be creating new task lists like this::

    >>> var tasklist = TaskList.new();
    >>> tasklist.insert(Task, { description: "Finish the hub.js tutorial." });

We'll deal with sharing task lists later. For now, let's move on to record 
arrays, which is how we'll provide the list of tasks to our apps.

Record Arrays
-------------

If this is your first time using Django, you'll have to take care of some
initial setup. Namely, you'll need to auto-generate some code that establishes a
Django :term:`project` -- a collection of settings for an instance of Django,
including database configuration, Django-specific options and
application-specific settings.

From the command line, ``cd`` into a directory where you'd like to store your
code, then run the command ``django-admin.py startproject mysite``. This will
create a ``mysite`` directory in your current directory.

.. admonition:: Mac OS X permissions

   If you're using Mac OS X, you may see the message "permission denied" when
   you try to run ``django-admin.py startproject``. This is because, on
   Unix-based systems like OS X, a file must be marked as "executable" before it
   can be run as a program. To do this, open Terminal.app and navigate (using
   the ``cd`` command) to the directory where :ref:`django-admin.py
   <ref-django-admin>` is installed, then run the command
   ``chmod +x django-admin.py``.

.. note::

    You'll need to avoid naming projects after built-in Python or Django
    components. In particular, this means you should avoid using names like
    ``django`` (which will conflict with Django itself) or ``test`` (which
    conflicts with a built-in Python package).

:ref:`django-admin.py <ref-django-admin>` should be on your system path if you
installed Django via ``python setup.py``. If it's not on your path, you can find
it in ``site-packages/django/bin``, where ```site-packages``` is a directory
within your Python installation. Consider symlinking to :ref:`django-admin.py
<ref-django-admin>` from some place on your path, such as
:file:`/usr/local/bin`.

.. admonition:: Where should this code live?

    If your background is in PHP, you're probably used to putting code under the
    Web server's document root (in a place such as ``/var/www``). With Django,
    you don't do that. It's not a good idea to put any of this Python code
    within your Web server's document root, because it risks the possibility
    that people may be able to view your code over the Web. That's not good for
    security.

    Put your code in some directory **outside** of the document root, such as
    :file:`/home/mycode`.

Let's look at what :djadmin:`startproject` created::

    mysite/
        __init__.py
        manage.py
        settings.py
        urls.py

These files are:

    * :file:`__init__.py`: An empty file that tells Python that this directory
      should be considered a Python package. (Read `more about packages`_ in the
      official Python docs if you're a Python beginner.)

    * :file:`manage.py`: A command-line utility that lets you interact with this
      Django project in various ways. You can read all the details about
      :file:`manage.py` in :ref:`ref-django-admin`.

    * :file:`settings.py`: Settings/configuration for this Django project.
      :ref:`topics-settings` will tell you all about how settings work.

    * :file:`urls.py`: The URL declarations for this Django project; a "table of
      contents" of your Django-powered site. You can read more about URLs in
      :ref:`topics-http-urls`.

.. _more about packages: http://docs.python.org/tut/node8.html#packages

The development server
----------------------

Let's verify this worked. Change into the :file:`mysite` directory, if you
haven't already, and run the command ``python manage.py runserver``. You'll see
the following output on the command line::

    Validating models...
    0 errors found.

    Django version 1.0, using settings 'mysite.settings'
    Development server is running at http://127.0.0.1:8000/
    Quit the server with CONTROL-C.

You've started the Django development server, a lightweight Web server written
purely in Python. We've included this with Django so you can develop things
rapidly, without having to deal with configuring a production server -- such as
Apache -- until you're ready for production.

Now's a good time to note: DON'T use this server in anything resembling a
production environment. It's intended only for use while developing. (We're in
the business of making Web frameworks, not Web servers.)

Now that the server's running, visit http://127.0.0.1:8000/ with your Web
browser. You'll see a "Welcome to Django" page, in pleasant, light-blue pastel.
It worked!

.. admonition:: Changing the port

    By default, the :djadmin:`runserver` command starts the development server
    on the internal IP at port 8000.

    If you want to change the server's port, pass
    it as a command-line argument. For instance, this command starts the server
    on port 8080:

    .. code-block:: bash

        python manage.py runserver 8080

    If you want to change the server's IP, pass it along with the port. So to
    listen on all public IPs (useful if you want to show off your work on other
    computers), use:

    .. code-block:: bash

        python manage.py runserver 0.0.0.0:8000

    Full docs for the development server can be found in the
    :djadmin:`runserver` reference.

Database setup
--------------

Now, edit :file:`settings.py`. It's a normal Python module with module-level
variables representing Django settings. Change these settings to match your
database's connection parameters:

    * :setting:`DATABASE_ENGINE` -- Either 'postgresql_psycopg2', 'mysql' or
      'sqlite3'. Other backends are :setting:`also available <DATABASE_ENGINE>`.

    * :setting:`DATABASE_NAME` -- The name of your database. If you're using
      SQLite, the database will be a file on your computer; in that case,
      ``DATABASE_NAME`` should be the full absolute path, including filename, of
      that file. If the file doesn't exist, it will automatically be created
      when you synchronize the database for the first time (see below).

      When specifying the path, always use forward slashes, even on Windows
      (e.g. ``C:/homes/user/mysite/sqlite3.db``).

    * :setting:`DATABASE_USER` -- Your database username (not used for SQLite).

    * :setting:`DATABASE_PASSWORD` -- Your database password (not used for
      SQLite).

    * :setting:`DATABASE_HOST` -- The host your database is on. Leave this as an
      empty string if your database server is on the same physical machine (not
      used for SQLite).

If you're new to databases, we recommend simply using SQLite (by setting
:setting:`DATABASE_ENGINE` to ``'sqlite3'``). SQLite is included as part of
Python 2.5 and later, so you won't need to install anything else.

.. note::

    If you're using PostgreSQL or MySQL, make sure you've created a database by
    this point. Do that with "``CREATE DATABASE database_name;``" within your
    database's interactive prompt.

    If you're using SQLite, you don't need to create anything beforehand - the
    database file will be created automatically when it is needed.

While you're editing :file:`settings.py`, take note of the
:setting:`INSTALLED_APPS` setting towards the bottom of the file. That variable
holds the names of all Django applications that are activated in this Django
instance. Apps can be used in multiple projects, and you can package and
distribute them for use by others in their projects.

By default, :setting:`INSTALLED_APPS` contains the following apps, all of which
come with Django:

    * :mod:`django.contrib.auth` -- An authentication system.

    * :mod:`django.contrib.contenttypes` -- A framework for content types.

    * :mod:`django.contrib.sessions` -- A session framework.

    * :mod:`django.contrib.sites` -- A framework for managing multiple sites
      with one Django installation.

These applications are included by default as a convenience for the common case.

Each of these applications makes use of at least one database table, though,
so we need to create the tables in the database before we can use them. To do
that, run the following command:

.. code-block:: bash

    python manage.py syncdb

The :djadmin:`syncdb` command looks at the :setting:`INSTALLED_APPS` setting and
creates any necessary database tables according to the database settings in your
:file:`settings.py` file. You'll see a message for each database table it
creates, and you'll get a prompt asking you if you'd like to create a superuser
account for the authentication system. Go ahead and do that.

If you're interested, run the command-line client for your database and type
``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), or ``.schema`` (SQLite) to
display the tables Django created.

.. admonition:: For the minimalists

    Like we said above, the default applications are included for the common
    case, but not everybody needs them. If you don't need any or all of them,
    feel free to comment-out or delete the appropriate line(s) from
    :setting:`INSTALLED_APPS` before running :djadmin:`syncdb`. The
    :djadmin:`syncdb` command will only create tables for apps in
    :setting:`INSTALLED_APPS`.

.. _creating-models:

Creating models
===============

Now that your environment -- a "project" -- is set up, you're set to start
doing work.

Each application you write in Django consists of a Python package, somewhere
on your `Python path`_, that follows a certain convention. Django comes with a
utility that automatically generates the basic directory structure of an app,
so you can focus on writing code rather than creating directories.

.. admonition:: Projects vs. apps

    What's the difference between a project and an app? An app is a Web
    application that does something -- e.g., a weblog system, a database of
    public records or a simple poll app. A project is a collection of
    configuration and apps for a particular Web site. A project can contain
    multiple apps. An app can be in multiple projects.

In this tutorial, we'll create our poll app in the :file:`mysite` directory,
for simplicity. As a consequence, the app will be coupled to the project --
that is, Python code within the poll app will refer to ``mysite.polls``.
Later in this tutorial, we'll discuss decoupling your apps for distribution.

To create your app, make sure you're in the :file:`mysite` directory and type
this command:

.. code-block:: bash

    python manage.py startapp polls

That'll create a directory :file:`polls`, which is laid out like this::

    polls/
        __init__.py
        models.py
        views.py

This directory structure will house the poll application.

The first step in writing a database Web app in Django is to define your models
-- essentially, your database layout, with additional metadata.

.. admonition:: Philosophy

   A model is the single, definitive source of data about your data. It contains
   the essential fields and behaviors of the data you're storing. Django follows
   the :ref:`DRY Principle <dry>`. The goal is to define your data model in one
   place and automatically derive things from it.

In our simple poll app, we'll create two models: polls and choices. A poll has
a question and a publication date. A choice has two fields: the text of the
choice and a vote tally. Each choice is associated with a poll.

These concepts are represented by simple Python classes. Edit the
:file:`polls/models.py` file so it looks like this::

    from django.db import models

    class Poll(models.Model):
        question = models.CharField(max_length=200)
        pub_date = models.DateTimeField('date published')

    class Choice(models.Model):
        poll = models.ForeignKey(Poll)
        choice = models.CharField(max_length=200)
        votes = models.IntegerField()

.. admonition:: Errors about :attr:`~django.db.models.Field.max_length`

   If Django gives you an error message saying that
   :attr:`~django.db.models.Field.max_length` is not a valid argument, you're
   most likely using an old version of Django. (This version of the tutorial is
   written for the latest development version of Django.) If you're using a
   Subversion checkout of Django's development version (see :ref:`the
   installation docs <topics-install>` for more information), you shouldn't have
   any problems.

   If you want to stick with an older version of Django, you'll want to switch
   to `the Django 0.96 tutorial`_, because this tutorial covers several features
   that only exist in the Django development version.

.. _the Django 0.96 tutorial: http://www.djangoproject.com/documentation/0.96/tutorial01/

The code is straightforward. Each model is represented by a class that
subclasses :class:`django.db.models.Model`. Each model has a number of class
variables, each of which represents a database field in the model.

Each field is represented by an instance of a :class:`~django.db.models.Field`
class -- e.g., :class:`~django.db.models.CharField` for character fields and
:class:`~django.db.models.DateTimeField` for datetimes. This tells Django what
type of data each field holds.

The name of each :class:`~django.db.models.Field` instance (e.g. ``question`` or
``pub_date`` ) is the field's name, in machine-friendly format. You'll use this
value in your Python code, and your database will use it as the column name.

You can use an optional first positional argument to a
:class:`~django.db.models.Field` to designate a human-readable name. That's used
in a couple of introspective parts of Django, and it doubles as documentation.
If this field isn't provided, Django will use the machine-readable name. In this
example, we've only defined a human-readable name for ``Poll.pub_date``. For all
other fields in this model, the field's machine-readable name will suffice as
its human-readable name.

Some :class:`~django.db.models.Field` classes have required elements.
:class:`~django.db.models.CharField`, for example, requires that you give it a
:attr:`~django.db.models.Field.max_length`. That's used not only in the database
schema, but in validation, as we'll soon see.

Finally, note a relationship is defined, using
:class:`~django.db.models.ForeignKey`. That tells Django each Choice is related
to a single Poll. Django supports all the common database relationships:
many-to-ones, many-to-manys and one-to-ones.

.. _`Python path`: http://docs.python.org/tut/node8.html#SECTION008110000000000000000

Activating models
=================

That small bit of model code gives Django a lot of information. With it, Django
is able to:

    * Create a database schema (``CREATE TABLE`` statements) for this app.
    * Create a Python database-access API for accessing Poll and Choice objects.

But first we need to tell our project that the ``polls`` app is installed.

.. admonition:: Philosophy

    Django apps are "pluggable": You can use an app in multiple projects, and
    you can distribute apps, because they don't have to be tied to a given
    Django installation.

Edit the :file:`settings.py` file again, and change the
:setting:`INSTALLED_APPS` setting to include the string ``'mysite.polls'``. So
it'll look like this::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'mysite.polls'
    )

Now Django knows ``mysite`` includes the ``polls`` app. Let's run another
command:

.. code-block:: bash

    python manage.py sql polls

You should see something similar to the following (the ``CREATE TABLE`` SQL
statements for the polls app):

.. code-block:: sql

    BEGIN;
    CREATE TABLE "polls_poll" (
        "id" serial NOT NULL PRIMARY KEY,
        "question" varchar(200) NOT NULL,
        "pub_date" timestamp with time zone NOT NULL
    );
    CREATE TABLE "polls_choice" (
        "id" serial NOT NULL PRIMARY KEY,
        "poll_id" integer NOT NULL REFERENCES "polls_poll" ("id"),
        "choice" varchar(200) NOT NULL,
        "votes" integer NOT NULL
    );
    COMMIT;

Note the following:

    * The exact output will vary depending on the database you are using.

    * Table names are automatically generated by combining the name of the app
      (``polls``) and the lowercase name of the model -- ``poll`` and
      ``choice``. (You can override this behavior.)

    * Primary keys (IDs) are added automatically. (You can override this, too.)

    * By convention, Django appends ``"_id"`` to the foreign key field name.
      Yes, you can override this, as well.

    * The foreign key relationship is made explicit by a ``REFERENCES``
      statement.

    * It's tailored to the database you're using, so database-specific field
      types such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or
      ``integer primary key`` (SQLite) are handled for you automatically. Same
      goes for quoting of field names -- e.g., using double quotes or single
      quotes. The author of this tutorial runs PostgreSQL, so the example
      output is in PostgreSQL syntax.

    * The :djadmin:`sql` command doesn't actually run the SQL in your database -
      it just prints it to the screen so that you can see what SQL Django thinks
      is required. If you wanted to, you could copy and paste this SQL into your
      database prompt. However, as we will see shortly, Django provides an
      easier way of committing the SQL to the database.

If you're interested, also run the following commands:

    * :djadmin:`python manage.py validate <validate>` -- Checks for any errors
      in the construction of your models.

    * :djadmin:`python manage.py sqlcustom polls <sqlcustom>` -- Outputs any
      :ref:`custom SQL statements <initial-sql>` (such as table modifications or
      constraints) that are defined for the application.

    * :djadmin:`python manage.py sqlclear polls <sqlclear>` -- Outputs the
      necessary ``DROP TABLE`` statements for this app, according to which
      tables already exist in your database (if any).

    * :djadmin:`python manage.py sqlindexes polls <sqlindexes>` -- Outputs the
      ``CREATE INDEX`` statements for this app.

    * :djadmin:`python manage.py sqlall polls <sqlall>` -- A combination of all
      the SQL from the :djadmin:`sql`, :djadmin:`sqlcustom`, and
      :djadmin:`sqlindexes` commands.

Looking at the output of those commands can help you understand what's actually
happening under the hood.

Now, run :djadmin:`syncdb` again to create those model tables in your database:

.. code-block:: bash

    python manage.py syncdb

The :djadmin:`syncdb` command runs the sql from 'sqlall' on your database for
all apps in :setting:`INSTALLED_APPS` that don't already exist in your database.
This creates all the tables, initial data and indexes for any apps you have
added to your project since the last time you ran syncdb. :djadmin:`syncdb` can
be called as often as you like, and it will only ever create the tables that
don't exist.

Read the :ref:`django-admin.py documentation <ref-django-admin>` for full
information on what the ``manage.py`` utility can do.

Playing with the API
====================

Now, let's hop into the interactive Python shell and play around with the free
API Django gives you. To invoke the Python shell, use this command:

.. code-block:: bash

    python manage.py shell

We're using this instead of simply typing "python", because ``manage.py`` sets
up the project's environment for you. "Setting up the environment" involves two
things:

    * Putting ``mysite`` on ``sys.path``. For flexibility, several pieces of
      Django refer to projects in Python dotted-path notation (e.g.
      ``'mysite.polls.models'``). In order for this to work, the ``mysite``
      package has to be on ``sys.path``.

      We've already seen one example of this: the :setting:`INSTALLED_APPS`
      setting is a list of packages in dotted-path notation.

    * Setting the ``DJANGO_SETTINGS_MODULE`` environment variable, which gives
      Django the path to your ``settings.py`` file.

.. admonition:: Bypassing manage.py

    If you'd rather not use ``manage.py``, no problem. Just make sure ``mysite``
    is at the root level on the Python path (i.e., ``import mysite`` works) and
    set the ``DJANGO_SETTINGS_MODULE`` environment variable to
    ``mysite.settings``.

    For more information on all of this, see the :ref:`django-admin.py
    documentation <ref-django-admin>`.

Once you're in the shell, explore the :ref:`database API <topics-db-queries>`::

    >>> from mysite.polls.models import Poll, Choice # Import the model classes we just wrote.

    # No polls are in the system yet.
    >>> Poll.objects.all()
    []

    # Create a new Poll.
    >>> import datetime
    >>> p = Poll(question="What's up?", pub_date=datetime.datetime.now())

    # Save the object into the database. You have to call save() explicitly.
    >>> p.save()

    # Now it has an ID. Note that this might say "1L" instead of "1", depending
    # on which database you're using. That's no biggie; it just means your
    # database backend prefers to return integers as Python long integer
    # objects.
    >>> p.id
    1

    # Access database columns via Python attributes.
    >>> p.question
    "What's up?"
    >>> p.pub_date
    datetime.datetime(2007, 7, 15, 12, 00, 53)

    # Change values by changing the attributes, then calling save().
    >>> p.pub_date = datetime.datetime(2007, 4, 1, 0, 0)
    >>> p.save()

    # objects.all() displays all the polls in the database.
    >>> Poll.objects.all()
    [<Poll: Poll object>]


Wait a minute. ``<Poll: Poll object>`` is, utterly, an unhelpful representation
of this object. Let's fix that by editing the polls model (in the
``polls/models.py`` file) and adding a
:meth:`~django.db.models.Model.__unicode__` method to both ``Poll`` and
``Choice``::

    class Poll(models.Model):
        # ...
        def __unicode__(self):
            return self.question

    class Choice(models.Model):
        # ...
        def __unicode__(self):
            return self.choice

.. admonition:: If :meth:`~django.db.models.Model.__unicode__` doesn't seem to work

   If you add the :meth:`~django.db.models.Model.__unicode__` method to your
   models and don't see any change in how they're represented, you're most
   likely using an old version of Django. (This version of the tutorial is
   written for the latest development version of Django.) If you're using a
   Subversion checkout of Django's development version (see :ref:`the
   installation docs <topics-install>` for more information), you shouldn't have
   any problems.

   If you want to stick with an older version of Django, you'll want to switch
   to `the Django 0.96 tutorial`_, because this tutorial covers several features
   that only exist in the Django development version.

.. _the Django 0.96 tutorial: http://www.djangoproject.com/documentation/0.96/tutorial01/

It's important to add :meth:`~django.db.models.Model.__unicode__` methods to
your models, not only for your own sanity when dealing with the interactive
prompt, but also because objects' representations are used throughout Django's
automatically-generated admin.

.. admonition:: Why :meth:`~django.db.models.Model.__unicode__` and not
                :meth:`~django.db.models.Model.__str__`?

    If you're familiar with Python, you might be in the habit of adding
    :meth:`~django.db.models.Model.__str__` methods to your classes, not
    :meth:`~django.db.models.Model.__unicode__` methods. We use
    :meth:`~django.db.models.Model.__unicode__` here because Django models deal
    with Unicode by default. All data stored in your database is converted to
    Unicode when it's returned.

    Django models have a default :meth:`~django.db.models.Model.__str__` method
    that calls :meth:`~django.db.models.Model.__unicode__` and converts the
    result to a UTF-8 bytestring. This means that ``unicode(p)`` will return a
    Unicode string, and ``str(p)`` will return a normal string, with characters
    encoded as UTF-8.

    If all of this is jibberish to you, just remember to add
    :meth:`~django.db.models.Model.__unicode__` methods to your models. With any
    luck, things should Just Work for you.

Note these are normal Python methods. Let's add a custom method, just for
demonstration::

    import datetime
    # ...
    class Poll(models.Model):
        # ...
        def was_published_today(self):
            return self.pub_date.date() == datetime.date.today()

Note the addition of ``import datetime`` to reference Python's standard
``datetime`` module.

Save these changes and start a new Python interactive shell by running
``python manage.py shell`` again::

    >>> from mysite.polls.models import Poll, Choice

    # Make sure our __unicode__() addition worked.
    >>> Poll.objects.all()
    [<Poll: What's up?>]

    # Django provides a rich database lookup API that's entirely driven by
    # keyword arguments.
    >>> Poll.objects.filter(id=1)
    [<Poll: What's up?>]
    >>> Poll.objects.filter(question__startswith='What')
    [<Poll: What's up?>]

    # Get the poll whose year is 2007. Of course, if you're going through this
    # tutorial in another year, change as appropriate.
    >>> Poll.objects.get(pub_date__year=2007)
    <Poll: What's up?>

    >>> Poll.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Poll matching query does not exist.

    # Lookup by a primary key is the most common case, so Django provides a
    # shortcut for primary-key exact lookups.
    # The following is identical to Poll.objects.get(id=1).
    >>> Poll.objects.get(pk=1)
    <Poll: What's up?>

    # Make sure our custom method worked.
    >>> p = Poll.objects.get(pk=1)
    >>> p.was_published_today()
    False

    # Give the Poll a couple of Choices. The create call constructs a new
    # choice object, does the INSERT statement, adds the choice to the set
    # of available choices and returns the new Choice object.
    >>> p = Poll.objects.get(pk=1)
    >>> p.choice_set.create(choice='Not much', votes=0)
    <Choice: Not much>
    >>> p.choice_set.create(choice='The sky', votes=0)
    <Choice: The sky>
    >>> c = p.choice_set.create(choice='Just hacking again', votes=0)

    # Choice objects have API access to their related Poll objects.
    >>> c.poll
    <Poll: What's up?>

    # And vice versa: Poll objects get access to Choice objects.
    >>> p.choice_set.all()
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
    >>> p.choice_set.count()
    3

    # The API automatically follows relationships as far as you need.
    # Use double underscores to separate relationships.
    # This works as many levels deep as you want; there's no limit.
    # Find all Choices for any poll whose pub_date is in 2007.
    >>> Choice.objects.filter(poll__pub_date__year=2007)
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]

    # Let's delete one of the choices. Use delete() for that.
    >>> c = p.choice_set.filter(choice__startswith='Just hacking')
    >>> c.delete()

For full details on the database API, see our :ref:`Database API reference
<topics-db-queries>`.

When you're comfortable with the API, read :ref:`part 2 of this tutorial
<intro-tutorial02>` to get Django's automatic admin working.
